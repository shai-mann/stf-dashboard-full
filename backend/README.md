# STF Dashboard [SERVER]

This tool is intended to provide an API to easily construct views of the Jenkins CToT test runs. It does this by categorizing individual builds under "Upstream" builds.

# Project Setup:

1) Copy the `workflow-config-template.json` file, renaming it to `workflow-config-file.json`
2) Enter the missing information into `workflow-config-file.json`.
   1) If not done so, initialize a local H2 database, and make note of the username, password, and URL.
3) Run the `database-ddl.sql` and `process-ddl.sql` files (found in `src/main/resources`).

# Project Structure:

## Upstream Jobs and Upstream Builds:

Upstream jobs/builds are Jenkins jobs/job runs that are linked to a single test suite (Multitenancy, VDCService-A, Networking, etc.). These jobs/builds only functionality is to trigger a run of that test suite against every available SDDC (VMC, AVS, etc.).

So, every `UpstreamJob` entity is linked to a set of `Job` entities, which each represent a single run of that test suite against a given sddc.

## Tests vs. TestResults

The `Test` table contains general information about a single test - linked to an `UpstreamJob` entity, which pairs the test with the suite it comes from.

Every entry in the `Test` table is unique based on three elements: the test's `name`, `dataProviderIndex`, and `className`. For this reason, the `Test` table may have multiple `cleanup` tests, but each is unique either by the SDDC it runs on, or the parameters it's given (via `dataProviderIndex`, which is a proxy for the parameters).

## Schemas: Processed vs. Public

The public schema is generated by the `WorkflowTools` process, and contains data scraped directly from Jenkins. However, this data is not formatted well for the purposes of the frontend that was designed for this project, so the data is processed into the `Processed` schema, where the structure will allow for easier accessing and collecting.


## Package Structure:

### Controllers, Repositories, Services, Models

All of these contain exactly what they sound like - using the MVC structure of Spring boot, `@RestControllers` go into the `controllers` package, `@Repositories` in the `repositories` package, and `@Services` in the `services` package.

The models package contains all entities (DB Models) to various tables in the two schemas present, split into `generated` - from the `public` schema - and `processed`, from the processed schema. The repositories also have this same split.

API models can be found in the `api` package, logging infrastructure can be found in the logging package, utilities (such as the enum types for SDDCs, SuiteTypes, and Statuses), and logic for processing data into the `processed` schema can be found in the `processing` package.